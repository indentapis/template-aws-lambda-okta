Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var crypto_1 = require("crypto");
var querystring_1 = require("querystring");
// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html
function hmac(key, str, encoding) {
    return crypto_1.createHmac('sha256', key)
        .update(str, 'utf8')
        .digest(encoding || 'hex');
}
function hash(string, encoding) {
    return crypto_1.createHash('sha256')
        .update(string, 'utf8')
        .digest(encoding || 'hex');
}
function encodeRfc3986(urlEncodedString) {
    return urlEncodedString.replace(/[!'()*]/g, function (c) {
        return [
            '%',
            c
                .charCodeAt(0)
                .toString(16)
                .toUpperCase()
        ].join('');
    });
}
function encodeRfc3986Full(str) {
    return encodeRfc3986(encodeURIComponent(str));
}
function getCanonicalString(options, request) {
    var path = request.path || '/';
    // S3 doesn't always encode characters > 127 correctly and
    // all services don't encode characters > 255 correctly
    // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
    if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
        path = encodeURI(decodeURI(path));
    }
    var queryIx = path.indexOf('?');
    var query;
    if (queryIx >= 0) {
        query = querystring_1.parse(path.slice(queryIx + 1));
        path = path.slice(0, queryIx);
    }
    else {
        query = {};
    }
    var parsedPath = { query: query, path: path };
    var pathStr = parsedPath.path;
    var headers = request.headers, queryStr = '', normalizePath = options.service !== 's3', decodePath = options.service === 's3', decodeSlashesInPath = options.service === 's3', firstValOnly = options.service === 's3', bodyHash;
    if (options.service === 's3') {
        bodyHash = 'UNSIGNED-PAYLOAD';
    }
    else {
        bodyHash =
            headers['X-Indent-Content-Sha256'] ||
                headers['x-Indent-content-sha256'] ||
                hash(request.body || '', 'hex');
    }
    if (query) {
        var reducedQuery_1 = Object.keys(query).reduce(function (obj, key) {
            if (!key)
                return obj;
            obj[encodeRfc3986Full(key)] = !Array.isArray(query[key])
                ? query[key]
                : firstValOnly
                    ? query[key][0]
                    : query[key];
            return obj;
        }, {});
        var encodedQueryPieces_1 = [];
        Object.keys(reducedQuery_1)
            .sort()
            .forEach(function (key) {
            if (Array.isArray(reducedQuery_1[key])) {
                ;
                reducedQuery_1[key]
                    .map(encodeRfc3986Full)
                    .sort()
                    .forEach(function (val) {
                    encodedQueryPieces_1.push(key + '=' + val);
                });
            }
            else {
                encodedQueryPieces_1.push(key + '=' + encodeRfc3986Full(reducedQuery_1[key]));
            }
        });
        queryStr = encodedQueryPieces_1.join('&');
    }
    if (pathStr !== '/') {
        if (normalizePath)
            pathStr = pathStr.replace(/\/{2,}/g, '/');
        pathStr = pathStr
            .split('/')
            .reduce(function (path, piece) {
            if (piece === void 0) { piece = ''; }
            if (normalizePath && piece === '..') {
                path.pop();
            }
            else if (!normalizePath || piece !== '.') {
                if (decodePath)
                    piece = decodeURIComponent(piece).replace(/\+/g, ' ');
                path.push(encodeRfc3986Full(piece));
            }
            return path;
        }, [])
            .join('/');
        if (pathStr[0] !== '/')
            pathStr = '/' + pathStr;
        if (decodeSlashesInPath)
            pathStr = pathStr.replace(/%2F/g, '/');
    }
    return [
        (request.method || 'POST').toUpperCase(),
        pathStr,
        queryStr,
        canonicalHeaders(options, request) + '\n',
        signedHeaders(options, request),
        bodyHash
    ].join('\n');
}
function canonicalHeaders(_options, request) {
    var headers = request.headers;
    function trimAll(header) {
        return header
            .toString()
            .trim()
            .replace(/\s+/g, ' ');
    }
    return Object.keys(headers)
        .sort(function (a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    })
        .map(function (key) {
        return key.toLowerCase() + ':' + trimAll(headers[key]);
    })
        .join('\n');
}
function signedHeaders(_options, request) {
    return Object.keys(request.headers)
        .map(function (key) {
        return key.toLowerCase();
    })
        .sort()
        .join(';');
}
function getSignatureKey(key, date, region, svc) {
    var kDate = hmac(date, 'IDV1' + key);
    var kRegion = hmac(region, kDate);
    var kService = hmac(svc, kRegion);
    var kSigning = hmac('idv1_request', kService);
    return kSigning;
}
function timestampFromNow() {
    return new Date().toISOString();
}
function getSigningAlg() {
    return 'IDV1-HMAC-SHA256';
}
function getCredentialScope(options) {
    var date = options.date, region = options.region, service = options.service;
    return [
        [date.getFullYear(), date.getMonth(), date.getDate()].join(''),
        region,
        service,
        'idv1_request'
    ].join('/');
}
function getStringToSign(options, request) {
    return [
        getSigningAlg(),
        getSigningTime(options),
        getCredentialScope(options),
        hash(getCanonicalString(options, request), 'hex')
    ].join('\n');
}
function getSigningTime(options) {
    if (!options.date || isNaN(options.date.getTime())) {
        return '';
    }
    return options.date.toISOString().replace(/(\-|:|\.\d*)/g, '');
}
function sign(secret, request) {
    if (request.body && typeof request.body !== 'string') {
        request = tslib_1.__assign(tslib_1.__assign({}, request), { body: JSON.stringify(request.body) });
    }
    var datetime = request.timestamp ||
        request.headers['X-Indent-Timestamp'] ||
        timestampFromNow();
    var date = new Date(datetime);
    var region = request.headers['X-Indent-Region'] || 'gcp:us-west2';
    var service = request.headers['X-Indent-Service'] || 'indent.v1.alertapi';
    var key = getSignatureKey(secret, datetime, region, service);
    var options = { date: date, region: region, service: service };
    var stringToSign = getStringToSign(options, request);
    return hmac(key, stringToSign, 'hex');
}
exports.sign = sign;
//# sourceMappingURL=sign.js.map