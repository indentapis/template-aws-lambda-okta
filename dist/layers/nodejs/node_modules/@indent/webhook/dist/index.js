Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CryptoJS = tslib_1.__importStar(require("crypto-js"));
function sign(_a) {
    var _b = _a.secret, secret = _b === void 0 ? '' : _b, _c = _a.payload, payload = _c === void 0 ? '' : _c;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_d) {
            return [2 /*return*/, CryptoJS.HmacSHA256(payload, secret).toString(CryptoJS.enc.Hex)];
        });
    });
}
exports.sign = sign;
function getSignaturePayload(opts) {
    var timestamp = opts.timestamp;
    var bodyString = '';
    if (typeof opts.body === 'string') {
        bodyString = opts.body;
    }
    else {
        bodyString = JSON.stringify(opts.body);
    }
    return "v0:" + timestamp + ":" + bodyString;
}
exports.getSignaturePayload = getSignaturePayload;
function verify(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var ts, sig, secret, body, signature, timestamp, throwError, payload, generatedSignature, isValidSignature;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (options.headers) {
                        ts = options.headers['X-Indent-Timestamp'] ||
                            options.headers['x-indent-timestamp'];
                        sig = options.headers['X-Indent-Signature'] ||
                            options.headers['x-indent-signature'];
                        options.timestamp = String(ts);
                        options.signature = String(sig);
                    }
                    if (!options.secret) {
                        throw new Error('@indent/webhook: verify(): missing options.secret');
                    }
                    if (!options.timestamp) {
                        throw new Error('@indent/webhook: verify(): missing options.timestamp');
                    }
                    if (!options.signature) {
                        throw new Error('@indent/webhook: verify(): missing options.signature');
                    }
                    if (!options.body) {
                        throw new Error('@indent/webhook: verify(): missing options.body');
                    }
                    secret = options.secret, body = options.body, signature = options.signature, timestamp = options.timestamp, throwError = options.throwError;
                    payload = getSignaturePayload({ body: body, timestamp: timestamp });
                    return [4 /*yield*/, sign({ secret: secret, payload: payload })];
                case 1:
                    generatedSignature = _a.sent();
                    isValidSignature = generatedSignature === signature;
                    if (typeof throwError === 'undefined' || throwError) {
                        if (!isValidSignature) {
                            throw new Error('@indent/webhook: verify(): invalid signature');
                        }
                    }
                    return [2 /*return*/, isValidSignature];
            }
        });
    });
}
exports.verify = verify;
exports.default = { sign: sign, verify: verify };
//# sourceMappingURL=index.js.map